package { 	import flash.display.MovieClip;	import flash.events.*;	import flash.errors.IOError; 	import flash.text.TextField;	import flash.net.URLRequest;	import flash.utils.getDefinitionByName;	import flash.utils.Timer;	import flash.geom.Rectangle;	import net.newecologyofthings.toolkit.*;		/**	 * @author Philip van Allen, vanallen@artcenter.edu, The New Ecology of Things Lab, Art Center College of Design	 * 	 * thanks to the component example by David Barlia david@barliesque.com	 * http://studio.barliesque.com/blog/2008/12/as3-component-custom-ui/	 * which was based on earlier work	 * http://flexion.wordpress.com/2007/06/27/building-flash-cs3-components/	 * 	 */	public class AnalogOut extends WidgetOutputController { 					// vars				// buttons		public var connectButton:ToggleButton;				// working variables 		public var theKnob:Knob;		private var knobRectangle:Rectangle;		public var knobRange:int = 100;		private var knobScale:Number;				private var outputLevelMin:Number = 0;		private var outputLevelMax:Number = 1023;		private var levelRange:Number = outputLevelMax - outputLevelMin;		private var lastLevel:Number;				private var lastOutputValue:Number = -1;				// instances of objects on the Flash stage		//		// input fields		// output fields		public var sInputSource:TextField;		public var sInputValue:TextField;		public var sOutputPort:TextField;		public var sOut:TextField;				// buttons		public var connect:MovieClip;				// objects		public var knob:MovieClip;		public var theLine:MovieClip;				// inherit constructor, so we don't need to create one		//public function AnalogInput(w:Number = NaN, h:Number = NaN) {			//super(w,h);		//} 						// functions				override public function setupAfterLoad( event:Event ): void {			super.setupAfterLoad(event);						// set up the buttons			connectButton = new ToggleButton(connect, this, "connect");			// PARAMETERS			//						// set up the defaults for this widget's parameters			paramsList.push(["connectButton", "on", "button"]);			// set the name used in the parameters XML			paramsXMLname = "AnalogOut_" + this.name;						// go			setupParams();						// set up knob			knobRectangle = new Rectangle(theLine.x,theLine.y,0,100);			theKnob = new Knob(knob, knobRectangle, this);			knobScale = (outputLevelMax - outputLevelMin)/knobRange;						// init vars			lastLevel = -100;						// set up the listener for the input source, and draw a line to it			setUpInputSource();		}					public function knobMove(position:Number): void {			var newLevel = position*(knobScale);			//trace("knob: " + position + "," + newRaw);			sendOutput(newLevel);		}				public function initControllerConnection() {					if (controller == "make") {				var prefixString = "/digitalout/" + controllerOutputNum + "/active 0";								theConnection.sendData("/service/osc/reader-writer/nlhubconfig/connect " + controllerIP + ":" + controllerPort);				// make sure the output port is not set up as a digital out				theConnection.sendData("/service/osc/reader-writer" + prefixString);				// output initial value				sendOutput(Number(sOut.text));			} else if (controller == "arduino") {				//theConnection.sendData("/service/arduino/reader-writer/nlhubconfig/connect " + serialPort + " " + serialBaudArduinoFirmata);				theConnection.sendData("/service/arduino/reader-writer/config/connect " + serialPort);				// output initial value				//sendOutput(Number(sOut.text));			} else if (controller == "osc") {				theConnection.sendData("/service/osc/reader-writer/connect " + controllerPort + " " + controllerIP);			} else if (controller == "hubFeed") {				theConnection.sendData("/service/core/pipe/connect/" + hubFeedName);			}		}				public function sendOutput(outputValue) {			var valueType:String;			//trace(outputValue);						// if sending to osc or hubfeed, check for string of parameters vs. a number			if ((controller == "osc" || controller == "hubFeed") && String(outputValue).indexOf(" ") >= 0) {				// treat as a string of parameters e.g. 10 5 20 to be sent via osc or hubfeed				//if (controller == "hubFeed") outputValue = '"' + String(outputValue) + '"';				outputValue = String(outputValue);				valueType = "string";			} else {				// treat it as a number				outputValue = Number(outputValue);				if (controller == "make" || controller == "arduino" || controller == "xbee") {					// number must be rounded					outputValue = Math.round(outputValue);				}				valueType = "number";			}						if (controller == "osc" || controller == "hubFeed") {				// decide if we should use the multiplier or not				if (valueType == "number") {					outputValue = String(Number(outputValue) * multiplier);				} 			} else if (controller == "arduino") {				outputValue = Math.floor(Number(outputValue)/4); // Arduino permits a PWM range of 0-255				outputValue = Math.min(outputValue,255);				outputValue = Math.max(0,outputValue);			}			if (connectButton.text == "on" && outputValue != lastOutputValue && connectionComplete) {				if (controller == "make") {					var prefixString = "/pwmout/" + controllerOutputNum + "/duty " + outputValue					theConnection.sendData("/service/osc/reader-writer" + prefixString);				} else if (controller == "arduino") {					theConnection.sendData("/service/arduino/reader-writer/{" + hubDeviceName + "}/analogout/" + controllerOutputNum + " " + outputValue);				} else if (controller == "osc") {					theConnection.sendData("/service/osc/reader-writer/" + controllerIP + ":" + controllerPort + oscString + " " + outputValue);				} else if (controller == "hubFeed") {					theConnection.sendData("/service/core/pipe/send/" + hubFeedName + " " + outputValue);				}				lastOutputValue = outputValue;			} else {				// we're not ready to send output yet, so make sure we send new value (compared to lastOutputValue) out once we are ready				lastOutputValue = -1;			}						sOut.text = String(outputValue);				}		override public function handleInputFeed( event:NetFeedEvent ):void {			//trace(this.name + ": " + event.netFeedValue + " " + event.widget.name);						var inputValue = event.netFeedValue;			sInputValue.text = String(inputValue);						// constrain the value to min and max			inputValue = Math.min(inputValue,outputLevelMax);			inputValue = Math.max(inputValue,outputLevelMin);									// set the knob position			if (theKnob.dragging == false) {				var newY = (theLine.y + knobRange) - (inputValue*(knobRange/levelRange));				knob.y = newY;			}									if (inputValue != lastLevel) {				sendOutput(inputValue);				lastLevel = inputValue;				//trace("newvol " + newVol);			}		}				public function connectWidget():void {			tryConnect();			connectButton.setState("on");		}				public function disconnectWidget():void {			disConnect();			connectButton.setState("off");		}				override public function draw():void {			super.draw();			//trace("in draw");			sInputSource.text = inputSource;			if (controller == "osc") {				sOutputPort.text = controller + " " + oscString;			} else if (controller == "hubFeed") {				sOutputPort.text = controller;			} else sOutputPort.text = controller + " " + controllerOutputNum;		}								//----------------------------------------------------------		// parameter getter setter functions		private var _controller:String = "arduino";		[Inspectable (name = "controller", variable = "controller", type = "String", enumeration="arduino,make,osc,hubFeed", defaultValue="arduino")]		public function get controller():String { return _controller; }		public function set controller(value:String):void {			_controller = value;			draw();		}	}}