package { 	import flash.display.MovieClip;	import flash.events.*;	import flash.text.TextField;	import flash.geom.Rectangle;	import flash.utils.*;	import net.newecologyofthings.toolkit.*;		/**	 * @author Philip van Allen, vanallen@artcenter.edu, The New Ecology of Things Lab, Art Center College of Design	 * 	 * thanks to the component example by David Barlia david@barliesque.com	 * http://studio.barliesque.com/blog/2008/12/as3-component-custom-ui/	 * which was based on earlier work	 * http://flexion.wordpress.com/2007/06/27/building-flash-cs3-components/	 * 	 */	public class DigitalIn extends WidgetInput { 				// vars						// buttons		public var connectButton:ToggleButton;		public var smoothButton:ToggleButton;		public var easeButton:ToggleButton;		public var invertButton:ToggleButton;		public var inputButton:ToggleButton;		// instances of objects on the Flash stage		//		// fields		//public var sInstanceName:TextField;		public var sInputSource:TextField;		public var sPort:TextField;		public var sOut:TextField;		public var sMin:TextField;		public var sMax:TextField;				// buttons		public var connect:MovieClip;		public var invert:MovieClip;		public var input:MovieClip;		public var smooth:MovieClip;		public var ease:MovieClip;				// objects				// inherit constructor, so we don't need to create one		//public function AnalogInput(w:Number = NaN, h:Number = NaN) {			//super(w,h);		//} 						// functions				override public function setupAfterLoad( event:Event ): void {			super.setupAfterLoad(event);									// set up the buttons			connectButton = new ToggleButton(connect, this, "connect");			smoothButton = new ToggleButton(smooth, this, "smooth");			easeButton = new ToggleButton(ease, this, "ease");			ease.visible = false;			invertButton = new ToggleButton(invert, this, "invert");			inputButton = new ToggleButton(input, this, "input");									// PARAMETERS			//						// set up the defaults for this widget's parameters			paramsList.push(["connectButton", "off", "button"]);			paramsList.push(["smoothButton", "off", "button"]);			paramsList.push(["invertButton", "off", "button"]);			paramsList.push(["sMin", "0", "text"]);			paramsList.push(["sMax", "1023", "text"]);						// set the name used in the parameters XML			paramsXMLname = "DigitalInput_" + this.name;							// put default values in text fields			sOut.text = "0";						inputType = "digital";						// go			setupParams();		}				override public function initControllerConnection() {			if (controller == "make") {				theConnection.sendData("/service/osc/reader-writer/nlhubconfig/connect " + controllerIP + ":" + controllerPort);				// make sure the input port is not set up as an analog in				theConnection.sendData("/service/osc/reader-writer/analogin/" + controllerInputNum + "/active 0");				theConnection.sendData("/service/osc/reader-writer/digitalin/" + controllerInputNum + "/active 0");				// set up the listen and polling -- /service/osc/reader-writer/nlhubconfig/listen [OSC pattern] [1 | 0] [samples per second]				theConnection.sendData("/service/osc/reader-writer/nlhubconfig/listen /digitalin/" + controllerInputNum + "/value 1 " + String(sampleRate));			} else if (controller == "xbee") {				theConnection.sendData("/service/xbee/reader-writer-series-1/connect " + serialPort + " " + serialBaudXbee);				//theConnection.sendData("/service/xbee/reader-writer/nlhubconfig/connect " + serialPort + " " + serialBaudXbee);				//theConnection.sendData("/service/xbee/reader-writer/" + xbeeRemoteID + "/digitalin/" + controllerInputNum + "/value");			} else if (controller == "arduino") {				theConnection.sendData("/service/arduino/reader-writer/config/connect " + serialPort);			} else {				super.initControllerConnection();			}		}				override public function finishConnect() {			if (controller == "xbee") { 				theConnection.sendData("/service/xbee/reader-writer-series-1/poll /{" + hubDeviceName + "}/" + xbeeRemoteID + "/digitalin/" + controllerInputNum + " 0 " + sampleRate);				//theConnection.sendData("/service/xbee/reader-writer-series-1/{" + hubDeviceName + "}/" + xbeeRemoteID + "/digitalin/" + controllerInputNum);			} else if (controller == "arduino") {				theConnection.sendData("/service/arduino/reader-writer/poll /{" + hubDeviceName + "}/digitalin/" + controllerInputNum + " 0 " + sampleRate);			}			super.finishConnect();		}				override public function handleButton(buttonType:String, buttonState:String) {			if (buttonType == "input") {				//trace("input button");				if (buttonState == "on") {					//fillSmoothingBuffer(rawHigh)					processRawValue(rawHigh, this);				} else if (buttonState =="off") {					//fillSmoothingBuffer(rawLow)					processRawValue(rawLow, this);				}			} else super.handleButton(buttonType, buttonState);		}				public function connectWidget():void {			tryConnect();			connectButton.setState("on");		}				public function disconnectWidget():void {			disConnect();			connectButton.setState("off");		}				override public function draw():void {			super.draw();			//trace("in draw");			if (controller == "inputSource") {				sInputSource.text = inputSource;			} else if (controller == "xbee") {				sInputSource.text = controller + " " + xbeeRemoteID + " " + controllerInputNum;			} else if (controller == "osc") {				sInputSource.text = controller + " " + oscString;			} else if (controller == "accelerometer") {				sInputSource.text = "accel " + controllerInputNum;			} else if (controller == "mic") {				sInputSource.text = controller;			} else {				sInputSource.text = controller + " " + controllerInputNum;			}						//sInstanceName.text = this.name;		}						//----------------------------------------------------------		// parameter getter setter functions	}}